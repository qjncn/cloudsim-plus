/*
 * CloudSim Plus: A modern, highly-extensible and easier-to-use Framework for
 * Modeling and Simulation of Cloud Computing Infrastructures and Services.
 * http://cloudsimplus.org
 *
 *     Copyright (C) 2015-2018 Universidade da Beira Interior (UBI, Portugal) and
 *     the Instituto Federal de Educação Ciência e Tecnologia do Tocantins (IFTO, Brazil).
 *
 *     This file is part of CloudSim Plus.
 *
 *     CloudSim Plus is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     CloudSim Plus is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with CloudSim Plus. If not, see <http://www.gnu.org/licenses/>.
 */
package org.cloudsimplus.heuristics;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A solution for a complex problem found using a {@link Heuristic} implementation.
 * A heuristic can generate multiple solutions until find an optimal or suboptimal
 * solution for the problem.
 * 使用{@link启发式}实现发现的一个复杂问题的解决方案。
 * 启发式可以产生多个解决方案，直到找到问题的最优或次优解决方案。
 *
 * @author Manoel Campos da Silva Filho
 * @param <T> the type used to store the result of the solution.
 * Check {@link #getResult()} for more details.
 * @since CloudSim Plus 1.0
 */
public interface HeuristicSolution<T> extends Comparable<HeuristicSolution<T>> {
    Logger LOGGER = LoggerFactory.getLogger(HeuristicSolution.class.getSimpleName());

    /**
     * An attribute that implements the Null Object Design Pattern for {@link HeuristicSolution}
     * objects.
     * 实现{@link HeuristicSolution}对象的空对象设计模式的属性。
     */
    HeuristicSolution NULL = new HeuristicSolutionNull();

	/**
	 * @return the heuristic that generated this solution.生成此解决方案的启发式
	 */
	Heuristic<HeuristicSolution<T>> getHeuristic();

    /**
     * Defines how good the solution is and it the inverse of the {@link #getCost()}.
     * As higher is the fitness,
     * better is a solution. How a solution fitness is computed is totally
     * dependent of the heuristic implementation being used
     * to find a solution.
     * 定义解决方案有多好，它是{@link #getCost()}的倒数。
     * 由于适合度越高，解决方案就越好。
     * 如何计算一个解决方案的适应度完全依赖于启发式实现被用于寻找一个解决方案。
     *
     * @return the solution fitness
     * @see #getCost()
     */
    default double getFitness() {
        return 1.0/getCost();
    }

    /**
     * Defines the cost of using this solution.
     * As higher is the cost, worse is a solution. How a solution cost is computed is totally
     * dependent of the heuristic implementation being used to find a solution.
     * 定义使用此解决方案的成本。
     * 成本越高，解决办法就越糟。
     * 如何计算一个解决方案的成本完全依赖于启发式实现被用于寻找一个解决方案。
     *
     * @return the solution cost
     * @see #getFitness()
     */
    double getCost();

    /**
     * Gets the result of the solution.
     * For instance, if a implementation of this interface aims to provide
     * a mapping between Cloudlets and Vm's, this type would be
     * a {@code  Map<Cloudlet, Vm>}, that will indicate which Vm will
     * run each Cloudlet.
     * This way, the type T of the solution is totally dependent of the problem
     * being solved by the heuristic implementation.
     * 得到解决方案的结果。例如，如果该接口的实现旨在提供Cloudlet和Vm之间的映射，
     * 则该类型将是{@code Map<Cloudlet, Vm>}，它将指示哪个Vm将运行每个Cloudlet。
     * 这样，解决方案的类型T完全依赖于启发式实现所解决的问题。
     * <p>
     * The result of solution is generated by a heuristic.
     * Getting an optimal or sub-optimal solution is the final goal of a heuristic.
     * 采用启发式方法生成求解结果。
     * 获得最优或次优解是启发式的最终目标。
     * </p>
     *
     * @return the object containing the result of the generated solution.
     */
    T getResult();
}
